name: Auto version & changelog

on:
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  autoversion:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      # 1) Get GitHub App token
      - name: Create GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      # 2) Checkout using the APP token (this is critical for bypass)
      - name: Checkout with app token
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: true

      # 3) Detect bump type from PR labels
      - name: Detect bump type from labels (required)
        id: bump
        run: |
          set -euo pipefail

          labels="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
          echo "PR labels: $labels"

          bump_type=""

          if [[ "$labels" =~ release:major ]]; then
            bump_type="major"
          elif [[ "$labels" =~ release:minor ]]; then
            bump_type="minor"
          elif [[ "$labels" =~ release:patch ]]; then
            bump_type="patch"
          fi

          if [[ -z "$bump_type" ]]; then
            echo "ERROR: One of 'release:major', 'release:minor', 'release:patch' labels is REQUIRED on the PR."
            exit 1
          fi

          echo "Using bump type: $bump_type"
          echo "type=$bump_type" >> "$GITHUB_OUTPUT"

      # 4) Compute new version & generate CHANGELOG.md
      - name: Compute new version & update CHANGELOG
        id: version
        env:
          BUMP_TYPE: ${{ steps.bump.outputs.type }}
        run: |
          set -euo pipefail

          DEFAULT_VERSION="0.0.0"

          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            CURRENT_TAG="$(git describe --tags --abbrev=0)"
            BASE_VERSION="${CURRENT_TAG#v}"
            echo "Last tag: $CURRENT_TAG (version $BASE_VERSION)"
          else
            CURRENT_TAG=""
            BASE_VERSION="$DEFAULT_VERSION"
            echo "No previous tag found, using base version $BASE_VERSION"
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

          case "$BUMP_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            *)
              echo "Unknown BUMP_TYPE: $BUMP_TYPE"
              exit 1
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          TAG="v$NEW_VERSION"

          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "New version: $NEW_VERSION"

          DATE="$(date +%Y-%m-%d)"
          TMP_CHANGELOG="$(mktemp)"

          echo "## v$NEW_VERSION - $DATE" >> "$TMP_CHANGELOG"
          echo >> "$TMP_CHANGELOG"

          if [[ -n "$CURRENT_TAG" ]]; then
            echo "Changes since $CURRENT_TAG:" >> "$TMP_CHANGELOG"
            git log "${CURRENT_TAG}..HEAD" --pretty=format:"- %s" >> "$TMP_CHANGELOG" || true
          else
            echo "Initial release:" >> "$TMP_CHANGELOG"
            git log --pretty=format:"- %s" >> "$TMP_CHANGELOG" || true
          fi

          echo >> "$TMP_CHANGELOG"
          echo >> "$TMP_CHANGELOG"

          # Diff range for file summary
          if [[ -n "$CURRENT_TAG" ]]; then
            DIFF_RANGE="${CURRENT_TAG}..HEAD"
          else
            EMPTY_TREE="$(git hash-object -t tree /dev/null)"
            DIFF_RANGE="$EMPTY_TREE..HEAD"
          fi

          echo "### File changes summary:" >> "$TMP_CHANGELOG"
          echo >> "$TMP_CHANGELOG"

          git diff --name-status $DIFF_RANGE > /tmp/namestatus.diff || true

          added=()
          modified=()
          removed=()
          renamed=()

          while read -r status path rest; do
            case "$status" in
              A)
                added+=("$path")
                ;;
              M)
                modified+=("$path")
                ;;
              D)
                removed+=("$path")
                ;;
              R* )
                old="$path"
                new="$rest"
                renamed+=("$old -> $new")
                ;;
            esac
          done < /tmp/namestatus.diff

          print_section() {
            local title="$1"; shift
            local -n arr=$1

            if [[ ${#arr[@]} -gt 0 ]]; then
              echo "$title:" >> "$TMP_CHANGELOG"
              for f in "${arr[@]}"; do
                echo "- \`$f\`" >> "$TMP_CHANGELOG"
              done
              echo >> "$TMP_CHANGELOG"
            fi
          }

          print_section "Added" added
          print_section "Modified" modified
          print_section "Removed" removed
          print_section "Renamed" renamed

          echo >> "$TMP_CHANGELOG"

          if [[ -f CHANGELOG.md ]]; then
            cat CHANGELOG.md >> "$TMP_CHANGELOG"
          fi

          mv "$TMP_CHANGELOG" CHANGELOG.md

          echo "Updated CHANGELOG.md (top):"
          head -n 40 CHANGELOG.md || true

      # 5) Commit, tag, push as the GitHub App
      - name: Commit release, tag and push
        env:
          VERSION: ${{ steps.version.outputs.new_version }}
        run: |
          set -euo pipefail

          TAG="v$VERSION"

          git config user.name "puz-release-bot[bot]"
          git config user.email "puz-release-bot[bot]@users.noreply.github.com"

          git add CHANGELOG.md

          if git diff --cached --quiet; then
            echo "No changes to commit, skipping commit & tag."
            exit 0
          fi

          git commit -m "chore(release): v$VERSION [skip ci]"
          git tag "$TAG"

          # Uses the app token from checkout (persist-credentials: true)
          git push origin HEAD:main
          git push origin "$TAG"